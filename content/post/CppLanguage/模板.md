---
title: "模板"
subtitle: ""
date: 2021-10-14T19:33:40+08:00
lastmod: 2021-10-14T19:33:40+08:00
draft: false
hidden: true
description: ""

tags: []
categories: ["Language"]
---
模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式。当使用泛型类型或者泛型函数时，在编译时将蓝图转化为特定的类或者函数。
<!--more-->

## 定义模板
类型参数的模板：
`template <typename T, typename U>`

非类型模板参数的模板：
`template <unsigned N,unsigned M>`
非类型模板参数的模板实参必须是常量表达式。


模板和头文件：
模板包含两种名字：
- 不依赖于模板参数的名字：必须可见，由模板提供者保证。
- 依赖模板参数的名字

用于实例化模板的所有函数、类型以及与类型关联的运算符的声明必须可见，由用户保证。


## 模板实参推断
对于函数模板，编译器利用调用中的函数确定其模板参数。

尾置返回类型：
~~~ cpp
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg){
    //
    return *beg;
}
~~~

类型转换模板：
`remove_reference`获取元素类型。
使用模板参数的成员，必须使用typename，表明告诉编译器其表示类型。


引用折叠：
- 例外规则一：当左值传递给函数的右值引用参数，且右值引用指向模板类型参数，编译器推断模板类型参数为实参的左值引用类型。
- 例外规则二：创建了引用的引用，则引用会折叠。引用折叠成左值引用类型，除了右值引用的右值引用仍然折叠成右值引用。
因此：
- 若一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值；
- 若实参是一个左值，则推断出的模板实参类型是一个左值引用，且函数参数将被实例化为一个左值引用参数。

规则暗示了我们可以将任意类型实参传递给T&&类型的函数参数。对于这种类型的参数，可以传递给右值也可以传递给左值。


理解std::move

~~~ cpp
template <typename T>
typename remove_reference<T>::type&& move(T&& t){
    return static_cast<typename remove_reference<T>::type&&>(t);
}

~~~

虽然不能隐式地将一个左值转化为右值引用，但可以用``显式地将一个左值转换为右值引用。

## 重载与模板


## 可变参数模板
可变参数函数通常是递归的。

## 模板特例化
`template <>`






